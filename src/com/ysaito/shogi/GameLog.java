package com.ysaito.shogi;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.Writer;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.util.Log;

public class GameLog implements Serializable {
  private static final String TAG = "GameLog";
  
  // TODO: add a flag to indicate the source of the log, e.g.,
  // generated by the software, or downloaded from elsewhere.
  
  // Common keys for mAttrs.
  public static final String A_TITLE = "title";
  public static final String A_LOCATION = "location";
  public static final String A_TIME_LIMIT = "timelimit";  
  public static final String A_TOURNAMENT = "tourament";
  public static final String A_BLACK_PLAYER = "blackplayer";
  public static final String A_WHITE_PLAYER = "whiteplayer";
  public static final String A_HANDICAP = "handicap";
  
  // List of attributes (player names, etc) found in the log. This field
  // must be an ordered map so that digest() can compute a deterministic value.
  private final TreeMap<String, String> mAttrs;
  
  private long mDate;  // UTC in millisec
  private final ArrayList<Move> mMoves;
  private String mDigest;  // cached value of getDigest().

  @Override public String toString() {
    StringBuilder b = new StringBuilder();
    for (Map.Entry<String, String> e: mAttrs.entrySet()) {
      b.append(e.getKey());
      b.append(": ");
      b.append(e.getValue());
    }
    return b.toString();
  }
  
  @Override public int hashCode() {
    throw new AssertionError("hashCode not implemented");
  }

  private GameLog() { 
    mAttrs = new TreeMap<String, String>();
    mMoves = new ArrayList<Move>();
  }
  
  public final String getAttr(String key) {
    return mAttrs.get(key);
  }
  
  public final Set<Map.Entry<String, String>> getAttrs() {
    return mAttrs.entrySet();
  }

  // Get the SHA-1 digest of this object.
  public String digest() {
    if (mDigest == null) {
      try {
        MessageDigest digest = MessageDigest.getInstance("SHA-1");
        for (Map.Entry<String, String> e : mAttrs.entrySet()) {
          digest.update(e.getKey().getBytes());
          digest.update(e.getValue().getBytes());
        }
        for (int i = 0; i < mMoves.size(); ++i) {
          digest.update(mMoves.get(i).toString().getBytes());
        }
        byte b[] = digest.digest();
        StringBuffer hex = new StringBuffer();
	for (int i=0;i< b.length;i++) {
	  hex.append(Integer.toHexString(b[i] & 0xff));
	}        
        mDigest = hex.toString();
      } catch (NoSuchAlgorithmException e) {
        throw new AssertionError("MessageDigest.NoSuchAlgorithmException: " + e.getMessage());
      }
    }
    return mDigest;
  }
  
  public final long getDate() { return mDate; }
  
  public final Move getMove(int n) { return mMoves.get(n); }
  public final int numMoves() { return mMoves.size(); }
  
  private static final Pattern DATE_PATTERN = Pattern.compile("開始日時[：:](.*)");
  private static final Pattern MOVE_PATTERN = Pattern.compile("\\s*[0-9]+\\s+(.*)");  

  // English key name (e.g., A_TITLE) to japanese KIF key name (e.g., 表題) 
  private static final HashMap<String, String> mAttrNames;
  private static final HashMap<String, Pattern> mAttrPatterns;
  static {
    mAttrNames = new HashMap<String, String>();
    mAttrNames.put(A_TITLE, "表題");
    mAttrNames.put(A_TOURNAMENT, "棋戦");  
    mAttrNames.put(A_TIME_LIMIT, "持ち時間");  
    mAttrNames.put(A_LOCATION, "場所");  
    mAttrNames.put(A_HANDICAP, "手合割");    
    mAttrNames.put(A_BLACK_PLAYER, "先手");    
    mAttrNames.put(A_WHITE_PLAYER, "後手");    
    
    mAttrPatterns = new HashMap<String, Pattern>();
    for (Map.Entry<String, String> e : mAttrNames.entrySet()) {
	mAttrPatterns.put(e.getKey(), 
			  Pattern.compile(e.getValue() + "[：:](.*)")); 
    }
  }

  private static final Pattern HTML_KIF_START_PATTERN = Pattern.compile(".*>\\s*(開始日時|棋戦|場所|表題|手合割|先手|後手)[:：].*");
  private static final Pattern HTML_KIF_END_PATTERN = Pattern.compile("([^<]*)<.*");

  /** Parse an embedded KIF file downloaded from http://wiki.optus.nu/.
   * Such a file can be created by saving a "テキスト表示" link directly to a file.
   * 
   * This method assumes that the file is encoded in EUC-JP.
   */
  public static GameLog fromHtml(InputStream stream) throws ParseException {
    Reader in = null;
    try {
      in = new InputStreamReader(stream, "EUC_JP");
    } catch (UnsupportedEncodingException e1) {
      Log.e(TAG, "Failed to parse file (unsupported encoding): " + e1.getMessage());
      return null;
    }
    try {
      BufferedReader reader = new BufferedReader(in);
      String line;
      StringBuilder output = new StringBuilder();
      boolean kifFound = false;
      while ((line = reader.readLine()) != null && !kifFound) {
        Matcher m = HTML_KIF_START_PATTERN.matcher(line);
        if (m.matches()) {
          output.append(m.group(1));
          output.append('\n');
          while ((line = reader.readLine()) != null) {
            m = HTML_KIF_END_PATTERN.matcher(line);
            if (m.matches()) {
              output.append(m.group(1));
              output.append('\n');
              kifFound = true;
              break;
            } else {
              output.append(line);
              output.append('\n');
            }
          }
          break;
        }
      }
      if (!kifFound) return null;
      return fromKif(new StringReader(output.toString()));
    } catch (IOException e2) {
      Log.e(TAG, "Failed to parse file: " + e2.getMessage());      
      return null;
    }
  }
  
  /**
   * Print the contents of this object to "stream" in KIF format.
   * @throws IOException
   */
  public void toKif(Writer stream) throws IOException {
    StringBuilder b = new StringBuilder();
    
    // Generate header lines
    if (mDate > 0) {
      b.append("開始日時: ").append(toKifDateString(mDate)).append("\n");
    }
    for (Map.Entry<String, String> e : mAttrs.entrySet()) {
      String japaneseName = mAttrNames.get(e.getKey());
      if (japaneseName == null) japaneseName = e.getKey();
      b.append(japaneseName).append(": ").append(e.getValue()).append("\n");
    }
    b.append("手数----指手---------消費時間--\n");
    Board board = new Board();
    board.initialize(Handicap.NONE);
    Player player = Player.BLACK;
    for (int i = 0; i < mMoves.size(); ++i) {
      Move move = mMoves.get(i);
      b.append(String.format("%4d %s\n", 
          i + 1, 
          move.toTraditionalNotation(board).toJapaneseString()));
      board.applyMove(player, move);
      player = Player.opponentOf(player);
    }
    stream.write(b.toString());
  }
  
  /** 
   * Given a KIF file encoded in UTF-8, parse it. If this method doesn't throw 
   * an exception, it always return a non-null GameLog object.
   */
  public static GameLog fromKif(Readable stream) throws ParseException {
    GameLog l = new GameLog();
    Scanner scanner = new Scanner(stream);
    Move prevMove = null;
    Player curPlayer = Player.BLACK;
    while (scanner.hasNextLine()) {
      String line = scanner.nextLine();
      boolean matched = false;
      for (Map.Entry<String, Pattern> e: mAttrPatterns.entrySet()) {
        Matcher matcher = e.getValue().matcher(line);  
        if (matcher.matches()) {
          l.mAttrs.put(e.getKey(), matcher.group(1));
          matched = true;
          break;
        }
      }
      if (matched) continue;
      Matcher matcher = DATE_PATTERN.matcher(line);
      if (matcher.matches()) {
        l.mDate = parseDate(matcher.group(1));
        continue;
      }
      if (line.startsWith("手数")) {
        continue;
      }
      if (line.startsWith("まで")) {
        continue;
      }
      matcher = MOVE_PATTERN.matcher(line);
      if (matcher.matches()) {
        String moveString = matcher.group(1);
        if (moveString.startsWith("投了")) {
          continue;
        } else {
          Move m = Move.fromKifString(prevMove, curPlayer, moveString);
          l.mMoves.add(m);
          prevMove = m;
          curPlayer = Player.opponentOf(curPlayer);
        }
      } else {
        Log.e(TAG, line + ": ignoring line");
      }
    }
    return l;
  }
  
  // Given a UTC in milliseconds, return a KIF-style date string.
  private static String toKifDateString(long dateMs) {
    Calendar c = new GregorianCalendar();
    c.setTimeInMillis(dateMs);
    return String.format("%04d/%02d/%02d %02d:%02d:%02d",
        c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH),
        c.get(Calendar.HOUR), c.get(Calendar.MINUTE), c.get(Calendar.SECOND));
  }
  
  // Exposed for unittesting only.
  public static long TEST_parseDate(String s) throws ParseException {
    return parseDate(s);
  }
  
  // Parse Japanese date string found in KIF file, return UTC in milliseconds. 
  // Supported format is:
  //    YYYY/MM/DD [HH[:MM[:SS]]]
  private static long parseDate(String s) throws ParseException {
    Scanner scanner = new Scanner(s);
    scanner.useDelimiter("[/\\s　]");

    if (!scanner.hasNext()) throw new ParseException(s + ": failed to parse year");
    final int year = Integer.parseInt(scanner.next());
    if (!scanner.hasNext()) throw new ParseException(s + ": failed to parse month");
    final int month = Integer.parseInt(scanner.next());
    if (!scanner.hasNext()) throw new ParseException(s + ": failed to parse day");
    final int day = Integer.parseInt(scanner.next());
    
    int hour = 0;
    int minute = 0;
    int sec = 0;
    
    scanner.useDelimiter("[:\\s　]");    
    if (scanner.hasNext()) hour = Integer.parseInt(scanner.next());
    if (scanner.hasNext()) minute = Integer.parseInt(scanner.next());
    if (scanner.hasNext()) sec = Integer.parseInt(scanner.next());

    // TODO(saito) support multiple timezones
    Calendar c = new GregorianCalendar();
    c.set(year, month, day, hour, minute, sec);
    return c.getTimeInMillis();
  }
}
