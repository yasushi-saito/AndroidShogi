package com.ysaito.shogi;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.Serializable;
import java.io.StringReader;
import java.io.Writer;
import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.util.Log;

public class GameLog implements Serializable {
  private static final String TAG = "GameLog";
  
  // TODO: add a flag to indicate the source of the log, e.g.,
  // generated by the software, or downloaded from elsewhere.
  
  // Common keys for mAttrs.
  public static final String A_TITLE = "表題";
  public static final String A_LOCATION = "場所";
  public static final String A_TIME_LIMIT =  "持ち時間";
  public static final String A_TOURNAMENT = "棋戦";
  public static final String A_BLACK_PLAYER = "先手";
  public static final String A_WHITE_PLAYER = "後手";
  public static final String A_HANDICAP = "手合割";    
  
  // mFlag values.
  public static final int FLAG_ON_SDCARD = (1 << 0);  // log is stored on sdcard
  
  // List of attributes (player names, etc) found in the log. This field
  // must be an ordered map so that digest() can compute a deterministic value.
  private TreeMap<String, String> mAttrs;
  
  private int mFlag;
  private long mStartTimeMs;  // UTC in millisec
  private ArrayList<Move> mMoves;
  private String mDigest;  // cached value of getDigest().

  @Override public String toString() {
    StringBuilder b = new StringBuilder();
    for (Map.Entry<String, String> e: mAttrs.entrySet()) {
      b.append(e.getKey());
      b.append(": ");
      b.append(e.getValue());
    }
    return b.toString();
  }
  
  @Override public int hashCode() {
    throw new AssertionError("hashCode not implemented");
  }

  private GameLog() {
    mFlag = 0;
    mAttrs = new TreeMap<String, String>();
    mMoves = new ArrayList<Move>();
  }
  
  public final String attr(String key) {
    return mAttrs.get(key);
  }
  
  public final Set<Map.Entry<String, String>> attrs() {
    return mAttrs.entrySet();
  }

  // Get the SHA-1 digest of this object.
  public String digest() {
    if (mDigest == null) {
      try {
        MessageDigest digest = MessageDigest.getInstance("SHA-1");
        for (Map.Entry<String, String> e : mAttrs.entrySet()) {
          digest.update(e.getKey().getBytes());
          digest.update(e.getValue().getBytes());
        }
        for (int i = 0; i < mMoves.size(); ++i) {
          digest.update(mMoves.get(i).toString().getBytes());
        }
        byte b[] = digest.digest();
        StringBuffer hex = new StringBuffer();
	for (int i=0;i< b.length;i++) {
	  hex.append(Integer.toHexString(b[i] & 0xff));
	}        
        mDigest = hex.toString();
      } catch (NoSuchAlgorithmException e) {
        throw new AssertionError("MessageDigest.NoSuchAlgorithmException: " + e.getMessage());
      }
    }
    return mDigest;
  }
  
  public final int getFlag() { return mFlag; }
  public final long getDate() { return mStartTimeMs; }
  
  public final Move move(int n) { return mMoves.get(n); }
  public final int numMoves() { return mMoves.size(); }
  
  private static final Pattern DATE_PATTERN = Pattern.compile("開始日時[：:](.*)");
  private static final Pattern MOVE_PATTERN = Pattern.compile("\\s*[0-9]+\\s+(.*)");  
  private static final Pattern OPTIONAL_DAY_OF_WEEK_PATTERN = Pattern.compile("[(（][月火水木金土日][）)]");
  
  private static final HashMap<String, Pattern> mAttrPatterns;
  
  public static final String STANDARD_ATTR_NAMES[] = {
    A_BLACK_PLAYER, A_WHITE_PLAYER, 
    A_TITLE, A_LOCATION, A_TIME_LIMIT, A_TOURNAMENT,
  };
  
  static {
    mAttrPatterns = new HashMap<String, Pattern>();
    for (String attr: STANDARD_ATTR_NAMES) {
	mAttrPatterns.put(attr, Pattern.compile(attr + "[：:](.*)")); 
    }
  }

  private static final Pattern HTML_KIF_START_PATTERN = Pattern.compile(".*>\\s*((開始日時|棋戦|場所|表題|手合割|先手|後手)[:：].*)");
  private static final Pattern HTML_KIF_END_PATTERN = Pattern.compile("([^<]*)<.*");

  public static GameLog newLog(
      long startTimeMs, 
      TreeMap<String, String> attrs,
      ArrayList<Move> moves) {
    GameLog log = new GameLog();
    log.mFlag = 0;
    log.mStartTimeMs = startTimeMs;
    log.mAttrs = new TreeMap<String,String>(attrs);
    log.mMoves = new ArrayList<Move>(moves);
    return log;
  }
      
      
  /** Parse an embedded KIF file downloaded from http://wiki.optus.nu/.
   * Such a file can be created by saving a "テキスト表示" link directly to a file.
   * 
   * This method assumes that the file is encoded in EUC-JP.
   */
  public static GameLog parseHtml(InputStream stream) throws ParseException {
    Reader in = null;
    try {
      in = new InputStreamReader(stream, "EUC_JP");
    } catch (UnsupportedEncodingException e1) {
      Log.e(TAG, "Failed to parse file (unsupported encoding): " + e1.getMessage());
      return null;
    }
    try {
      BufferedReader reader = new BufferedReader(in);
      String line;
      StringBuilder output = new StringBuilder();
      boolean kifFound = false;
      while ((line = reader.readLine()) != null && !kifFound) {
        Matcher m = HTML_KIF_START_PATTERN.matcher(line);
        if (m.matches()) {
          output.append(m.group(1));
          output.append('\n');
          while ((line = reader.readLine()) != null) {
            m = HTML_KIF_END_PATTERN.matcher(line);
            if (m.matches()) {
              output.append(m.group(1));
              output.append('\n');
              kifFound = true;
              break;
            } else {
              output.append(line);
              output.append('\n');
            }
          }
          break;
        }
      }
      if (!kifFound) return null;
      return parseKif(new StringReader(output.toString()));
    } catch (IOException e2) {
      Log.e(TAG, "Failed to parse file: " + e2.getMessage());      
      return null;
    }
  }
  
  /**
   * Print the contents of this object to "stream" in KIF format.
   * @throws IOException
   */
  public void toKif(Writer stream) throws IOException {
    StringBuilder b = new StringBuilder();
    
    // Generate header lines
    if (mStartTimeMs > 0) {
      b.append("開始日時: ").append(toKifDateString(mStartTimeMs)).append("\n");
    }
    for (Map.Entry<String, String> e : mAttrs.entrySet()) {
      String japaneseName = e.getKey();
      b.append(japaneseName).append(": ").append(e.getValue()).append("\n");
    }
    b.append("手数----指手---------消費時間--\n");
    Board board = new Board();
    board.initialize(Handicap.NONE);
    Player player = Player.BLACK;
    for (int i = 0; i < mMoves.size(); ++i) {
      Move move = mMoves.get(i);
      b.append(String.format("%4d %s\n", 
          i + 1, 
          move.toTraditionalNotation(board).toJapaneseString()));
      board.applyMove(player, move);
      player = Player.opponentOf(player);
    }
    stream.write(b.toString());
  }
  
  /** 
   * Given a KIF file encoded in UTF-8, parse it. If this method doesn't throw 
   * an exception, it always return a non-null GameLog object.
   */
  public static GameLog parseKif(Readable stream) throws ParseException {
    GameLog l = new GameLog();
    l.mFlag = FLAG_ON_SDCARD;
    
    Scanner scanner = new Scanner(stream);
    Move prevMove = null;
    Player curPlayer = Player.BLACK;
    while (scanner.hasNextLine()) {
      String line = scanner.nextLine();
      boolean matched = false;
      for (Map.Entry<String, Pattern> e: mAttrPatterns.entrySet()) {
        Matcher matcher = e.getValue().matcher(line);  
        if (matcher.matches()) {
          Log.d(TAG, "MATCH: " + e.getKey() + "=>" + matcher.group(1));
          l.mAttrs.put(e.getKey(), matcher.group(1));
          matched = true;
          break;
        }
      }
      if (matched) continue;
      Matcher matcher = DATE_PATTERN.matcher(line);
      if (matcher.matches()) {
        l.mStartTimeMs = parseDate(matcher.group(1));
        continue;
      }
      
      // Skip lines that don't contain information
      if (line.startsWith("手数")) continue;
      if (line.startsWith("まで")) continue;
      
      matcher = MOVE_PATTERN.matcher(line);
      if (matcher.matches()) {
        String moveString = matcher.group(1);
        if (moveString.startsWith("投了")) {
          continue;
        } else {
          Move m = Move.fromKifString(prevMove, curPlayer, moveString);
          l.mMoves.add(m);
          prevMove = m;
          curPlayer = Player.opponentOf(curPlayer);
        }
      } else {
        Log.e(TAG, line + ": ignoring line");
      }
    }
    return l;
  }
  
  // Given a UTC in milliseconds, return a KIF-style date string.
  private static String toKifDateString(long dateMs) {
    Calendar c = new GregorianCalendar();
    c.setTimeInMillis(dateMs);
    return String.format("%04d/%02d/%02d %02d:%02d:%02d",
        c.get(Calendar.YEAR), c.get(Calendar.MONTH), c.get(Calendar.DAY_OF_MONTH),
        c.get(Calendar.HOUR), c.get(Calendar.MINUTE), c.get(Calendar.SECOND));
  }
  
  // Exposed for unittesting only.
  public static long TEST_parseDate(String s) throws ParseException {
    return parseDate(s);
  }
  
  // Parse Japanese date string found in KIF file, return UTC in milliseconds. 
  // Supported format is:
  //    YYYY/MM/DD [HH[:MM[:SS]]]
  private static long parseDate(String s) throws ParseException {
    Scanner scanner = new Scanner(s);
    scanner.useDelimiter("[/\\s　(（]");

    int year = 0;
    int month = 0;
    int day = 0;
    int hour = 0;
    int minute = 0;
    int sec = 0;
    
    try {
      if (!scanner.hasNext()) throw new ParseException(s + ": failed to parse year");
      year = Integer.parseInt(scanner.next());
      if (!scanner.hasNext()) throw new ParseException(s + ": failed to parse month");
      month = Integer.parseInt(scanner.next());
      if (!scanner.hasNext()) throw new ParseException(s + ": failed to parse day");
      day = Integer.parseInt(scanner.next());
    
      try {
        scanner.skip(OPTIONAL_DAY_OF_WEEK_PATTERN);
      } catch (NoSuchElementException e) {
        ;
      }
      scanner.useDelimiter("[:\\s　]");    
      if (scanner.hasNext()) hour = Integer.parseInt(scanner.next());
      if (scanner.hasNext()) minute = Integer.parseInt(scanner.next());
      if (scanner.hasNext()) sec = Integer.parseInt(scanner.next());
    } catch (NumberFormatException e) {
      Log.e(TAG, "Failed to parse "+ s + ": " + e.getMessage());
    }
    // TODO(saito) support multiple timezones
    Calendar c = new GregorianCalendar();
    c.set(year, month, day, hour, minute, sec);
    return c.getTimeInMillis();
  }
}
